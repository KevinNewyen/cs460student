<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <title>Lunar New Year Festival â€“ Three.js Interactive Scene</title>
    <style>
      html,
      body {
        margin: 0;
        padding: 0;
        overflow: hidden;
        height: 100%;
        background: #000;
        color: #fff;
        font-family: sans-serif;
      }
      #overlay {
        position: absolute;
        top: 0;
        left: 0;
        width: 100%;
        height: 100%;
        display: flex;
        flex-direction: column;
        justify-content: center;
        align-items: center;
        background: rgba(0, 0, 0, 0.7);
        cursor: pointer;
      }
      #overlay.hidden {
        display: none;
      }
      #overlay h1 {
        margin-bottom: 1rem;
        font-size: 2rem;
      }
      #overlay p {
        margin: 0.25rem 0;
      }
    </style>
    <script async src="https://unpkg.com/es-module-shims@1.6.3/dist/es-module-shims.js"></script>
    <script type="importmap">
      {
        "imports": {
          "three": "https://unpkg.com/three@latest/build/three.module.js",
          "three/addons/": "https://unpkg.com/three@latest/examples/jsm/"
        }
      }
    </script>
  </head>
  <body>

    <script type="module">
      import * as THREE from 'three';
      import { PointerLockControls } from 'three/addons/controls/PointerLockControls.js';
      import { GLTFLoader } from 'three/addons/loaders/GLTFLoader.js';

      let camera, scene, renderer, controls;
      let moveForward = false,
        moveBackward = false,
        moveLeft = false,
        moveRight = false;
      const velocity = new THREE.Vector3();
      const direction = new THREE.Vector3();
      let prevTime = performance.now();
      const fireworks = [];
      const collidableObjects = [];
      const glbColliders = [];
      const festivalMeshes = [];
      const downRaycaster = new THREE.Raycaster();
      const forwardRaycaster = new THREE.Raycaster();
      let velocityY = 0;
      const GRAVITY = 30; 
      const playerHeight = 16;
      const ACTOR_SCALE = 3;
      const FIREWORK_PALETTES = [
        [0xff0000, 0x00ff00, 0xffd700, 0xffa500, 0xffffff],
        [0x00008b, 0x4b0082, 0xc0c0c0, 0xffffff]
      ];

      const mixers = [];

      init();
      animate();

      function init() {
        scene = new THREE.Scene();
        scene.background = new THREE.Color(0x000000);
        scene.fog = new THREE.Fog(0x000000, 50, 300);

        camera = new THREE.PerspectiveCamera(
          75,
          window.innerWidth / window.innerHeight,
          1,
          1000
        );

        camera.position.set(0, playerHeight, 20);


        renderer = new THREE.WebGLRenderer({ antialias: true });
        renderer.setPixelRatio(window.devicePixelRatio);
        renderer.setSize(window.innerWidth, window.innerHeight);
        document.body.appendChild(renderer.domElement);

        controls = new PointerLockControls(camera, renderer.domElement);

        scene.add(controls.object);


        renderer.domElement.addEventListener('click', () => {
          if (!controls.isLocked) controls.lock();
        });

        document.addEventListener('keydown', onKeyDown);
        document.addEventListener('keyup', onKeyUp);

        const ambient = new THREE.AmbientLight(0xffb347, 1.5);
        scene.add(ambient);
        const sunLight = new THREE.DirectionalLight(0xffb347, 1.0);
        sunLight.position.set(50, 100, -30);
        scene.add(sunLight);

        scene.fog = new THREE.Fog(0xffb347, 50, 300);

        const cubeLoader = new THREE.CubeTextureLoader();

        const textureCube = cubeLoader.load([
          'px.png', 'nx.png',
          'py.png', 'ny.png',
          'pz.png', 'nz.png'
        ]);
        scene.background = textureCube;
        const gltfLoader = new GLTFLoader();
        gltfLoader.load(
          'festival.glb',
          (gltf) => {
            const model = gltf.scene;
            model.scale.set(8, 8, 8);
            scene.add(model);
            model.updateMatrixWorld(true);
            model.traverse((child) => {
              if (child.isMesh) {
                child.castShadow = true;
                child.receiveShadow = true;
                const box = new THREE.Box3().setFromObject(child);
                glbColliders.push(box);
                festivalMeshes.push(child);
              }
            });
          },
          undefined,
          (error) => {
            console.error('An error occurred loading festival.glb:', error);
          }
        );
        gltfLoader.load(
          'lantern.glb',
          (gltf) => {
            const baseModel = gltf.scene;
            baseModel.scale.set(0.25, 0.25, 0.25);

            const LANTERN_COUNT = 25;

            for (let i = 0; i < LANTERN_COUNT; i++) {
              const lantern = baseModel.clone(true);

              lantern.position.set(
                (Math.random() - 0.5) * 200, 
                75 + Math.random() * 20,     
                (Math.random() - 0.5) * 200  
              );

              lantern.rotation.y = Math.random() * Math.PI * 2;
              lantern.updateMatrixWorld(true);
              scene.add(lantern);

              lantern.traverse((child) => {
                if (child.isMesh) {
                  child.castShadow = true;
                  child.receiveShadow = true;
                  const box = new THREE.Box3().setFromObject(child);
                  glbColliders.push(box);
                  festivalMeshes.push(child);
                }
              });
            }
          },
          undefined,
          (error) => {
            console.error('An error occurred loading lantern.glb:', error);
          }
        );


        const lionLoader = new GLTFLoader();
        lionLoader.load(
          'lion.glb',
          (gltf) => {
            const lionModel = gltf.scene;
            lionModel.scale.set(300, 300, 300);
            lionModel.position.set(-150, 35, -65);
            lionModel.rotation.y = 360;
            scene.add(lionModel);
            const mixer = new THREE.AnimationMixer(lionModel);
            const clip = THREE.AnimationClip.findByName(gltf.animations, 'Take 001');
            if (clip) {
              const action = mixer.clipAction(clip);
              action.loop = THREE.LoopRepeat;
              action.play();
            }
            mixers.push(mixer);
          },
          undefined,
          (error) => {
            console.error('An error occurred loading lion.glb:', error);
          }
        );
        lionLoader.load(
          'lion.glb',
          (gltf) => {
            const lionModel = gltf.scene;
            lionModel.scale.set(300, 300, 300);
            lionModel.position.set(150, 0, 0);
            lionModel.rotation.y = 150;
            scene.add(lionModel);
            const mixer = new THREE.AnimationMixer(lionModel);
            const clip = THREE.AnimationClip.findByName(gltf.animations, 'Take 001');
            if (clip) {
              const action = mixer.clipAction(clip);
              action.loop = THREE.LoopRepeat;
              action.play();
            }
            mixers.push(mixer);
          },
          undefined,
          (error) => {
            console.error('An error occurred loading lion.glb:', error);
          }
        );
        const fireworkLoader = new GLTFLoader();
        fireworkLoader.load(
          'firework.glb',
          (gltf) => {
            function createFireworkInstance(delaySeconds) {
              const firework = gltf.scene.clone(true);
              firework.scale.set(3, 3, 3);
              firework.position.set(
                (Math.random() - 0.5) * 200,
                60 + Math.random() * 20,
                (Math.random() - 0.5) * 200
              );
              scene.add(firework);
              const mixer = new THREE.AnimationMixer(firework);
              const clip = THREE.AnimationClip.findByName(gltf.animations, 'CINEMA_4D_Main');
              if (clip) {
                const action = mixer.clipAction(clip);
                action.loop = THREE.LoopRepeat;
                action.paused = true;
                setTimeout(() => {
                  action.paused = false;
                  action.reset();
                  action.play();
                }, delaySeconds * 1000);
              }
              mixer.addEventListener('loop', () => {
                firework.position.set(
                  (Math.random() - 0.5) * 200,
                  60 + Math.random() * 20,
                  (Math.random() - 0.5) * 200
                );
              });
              mixers.push(mixer);
            }
            createFireworkInstance(0);
            createFireworkInstance(2);
            createFireworkInstance(4);
          },
          undefined,
          (error) => {
            console.error('An error occurred loading firework.glb:', error);
          }
        );
      }
      function onWindowResize() {
        camera.aspect = window.innerWidth / window.innerHeight;
        camera.updateProjectionMatrix();
        renderer.setSize(window.innerWidth, window.innerHeight);
      }
      function onKeyDown(event) {
        switch (event.code) {
          case 'KeyW':
          case 'ArrowUp':
            moveForward = true;
            break;
          case 'KeyA':
          case 'ArrowLeft':
            moveLeft = true;
            break;
          case 'KeyS':
          case 'ArrowDown':
            moveBackward = true;
            break;
          case 'KeyD':
          case 'ArrowRight':
            moveRight = true;
            break;
        }
      }

      function onKeyUp(event) {
        switch (event.code) {
          case 'KeyW':
          case 'ArrowUp':
            moveForward = false;
            break;
          case 'KeyA':
          case 'ArrowLeft':
            moveLeft = false;
            break;
          case 'KeyS':
          case 'ArrowDown':
            moveBackward = false;
            break;
          case 'KeyD':
          case 'ArrowRight':
            moveRight = false;
            break;
        }
      }

      function animate() {
        requestAnimationFrame(animate);

        const time = performance.now();
        const delta = (time - prevTime) / 1000;

        velocityY -= GRAVITY * delta;
        controls.object.position.y += velocityY * delta;
        const prevCamPosition = controls.object.position.clone();

        if (controls.isLocked === true) {
          velocity.x -= velocity.x * 10.0 * delta;
          velocity.z -= velocity.z * 10.0 * delta;
          direction.z = Number(moveForward) - Number(moveBackward);
          direction.x = Number(moveRight) - Number(moveLeft);
          direction.normalize();
          const acceleration = 400.0;
          if (moveForward || moveBackward) velocity.z -= direction.z * acceleration * delta;
          if (moveLeft || moveRight) velocity.x -= direction.x * acceleration * delta;
          controls.moveRight(-velocity.x * delta);
          controls.moveForward(-velocity.z * delta);
          const yMin = 2;
          if (controls.object.position.y < yMin) {
            controls.object.position.y = yMin;
          }
        }

        if (festivalMeshes.length > 0) {
          const rayOrigin = controls.object.position.clone();
          rayOrigin.y += 10;
          downRaycaster.ray.origin.copy(rayOrigin);
          downRaycaster.ray.direction.set(0, -1, 0);
          const intersections = downRaycaster.intersectObjects(festivalMeshes, true);
          if (intersections.length > 0) {
            const groundY = intersections[0].point.y;
            const heightOffset = playerHeight * 0.5;
            const currentFeetY = controls.object.position.y - heightOffset;
            const targetFeetY = groundY;
            const stepHeight = playerHeight * 0.5;
            const deltaHeight = targetFeetY - currentFeetY;
            if (deltaHeight > -0.1 && deltaHeight < stepHeight) {
              controls.object.position.y = groundY + heightOffset;
              velocityY = 0;
            }
          }
          const forward = new THREE.Vector3(0, 0, -1).applyQuaternion(camera.quaternion).normalize();

          const forwardOrigin = controls.object.position.clone();
          forwardOrigin.y -= playerHeight * 0.5;
          forwardRaycaster.ray.origin.copy(forwardOrigin);
          forwardRaycaster.ray.direction.copy(forward);
          const obstacles = forwardRaycaster.intersectObjects(festivalMeshes, true);
          if (obstacles.length > 0) {
            const feetLevel = controls.object.position.y - playerHeight * 0.5; 
            const stepMargin = playerHeight * 0.1;
            const maxDistance = 1.0; 
            for (let j = 0; j < obstacles.length; j++) {
              const ob = obstacles[j];
              if (ob.distance < maxDistance) {
                if (ob.point.y > feetLevel + stepMargin) {
                  controls.object.position.x = prevCamPosition.x;
                  controls.object.position.z = prevCamPosition.z;
                  velocity.x = 0;
                  velocity.z = 0;
                  velocityY = 0;
                  break;
                }
              }
            }
          }
        }
        mixers.forEach((mixer) => mixer.update(delta));

        prevTime = time;
        renderer.render(scene, camera);
      }
    </script>
  </body>
</html>