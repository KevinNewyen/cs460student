<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <title>Lunar New Year Festival â€“ Three.js Interactive Scene</title>
    <style>
      html,
      body {
        margin: 0;
        padding: 0;
        overflow: hidden;
        height: 100%;
        background: #000;
        color: #fff;
        font-family: sans-serif;
      }
      #overlay {
        position: absolute;
        top: 0;
        left: 0;
        width: 100%;
        height: 100%;
        display: flex;
        flex-direction: column;
        justify-content: center;
        align-items: center;
        background: rgba(0, 0, 0, 0.7);
        cursor: pointer;
      }
      #overlay.hidden {
        display: none;
      }
      #overlay h1 {
        margin-bottom: 1rem;
        font-size: 2rem;
      }
      #overlay p {
        margin: 0.25rem 0;
      }
    </style>
    <script async src="https://unpkg.com/es-module-shims@1.6.3/dist/es-module-shims.js"></script>
    <script type="importmap">
      {
        "imports": {
          "three": "https://unpkg.com/three@latest/build/three.module.js",
          "three/addons/": "https://unpkg.com/three@latest/examples/jsm/"
        }
      }
    </script>
  </head>
  <body>

    <script type="module">
      import * as THREE from 'three';
      import { PointerLockControls } from 'three/addons/controls/PointerLockControls.js';
      import { GLTFLoader } from 'three/addons/loaders/GLTFLoader.js';
      import { FontLoader } from 'three/addons/loaders/FontLoader.js';
      import { TextGeometry } from 'three/addons/geometries/TextGeometry.js';


      let camera, scene, renderer, controls;
      let moveForward = false,
        moveBackward = false,
        moveLeft = false,
        moveRight = false;
      const velocity = new THREE.Vector3();
      const direction = new THREE.Vector3();
      let prevTime = performance.now();
      const fireworks = [];
      const collidableObjects = [];
      const glbColliders = [];
      const festivalMeshes = [];
      const downRaycaster = new THREE.Raycaster();
      const forwardRaycaster = new THREE.Raycaster();
      let velocityY = 0;
      const GRAVITY = 30; 
      const playerHeight = 16;
      const ACTOR_SCALE = 3;
      const FIREWORK_PALETTES = [
        [0xff0000, 0x00ff00, 0xffd700, 0xffa500, 0xffffff],
        [0x00008b, 0x4b0082, 0xc0c0c0, 0xffffff]
      ];
      const lanterns = [];


      const mixers = [];

      init();
      animate();

      function init() {
        scene = new THREE.Scene();
        scene.background = new THREE.Color(0x000000);
        scene.fog = new THREE.Fog(0x000000, 50, 300);

        camera = new THREE.PerspectiveCamera(
          75,
          window.innerWidth / window.innerHeight,
          1,
          1000
        );

        camera.position.set(0, playerHeight, 20);


        renderer = new THREE.WebGLRenderer({ antialias: true });
        renderer.setPixelRatio(window.devicePixelRatio);
        renderer.setSize(window.innerWidth, window.innerHeight);
        document.body.appendChild(renderer.domElement);

        controls = new PointerLockControls(camera, renderer.domElement);

        scene.add(controls.object);


        renderer.domElement.addEventListener('click', () => {
          if (!controls.isLocked) controls.lock();
        });

        document.addEventListener('keydown', onKeyDown);
        document.addEventListener('keyup', onKeyUp);

        const ambient = new THREE.AmbientLight(0xffb347, 1.5);
        scene.add(ambient);
        const sunLight = new THREE.DirectionalLight(0xffb347, 1.0);
        sunLight.position.set(50, 100, -30);
        scene.add(sunLight);

        scene.fog = new THREE.Fog(0xffb347, 50, 300);

        const cubeLoader = new THREE.CubeTextureLoader();

        const textureCube = cubeLoader.load([
          'px.png', 'nx.png',
          'py.png', 'ny.png',
          'pz.png', 'nz.png'
        ]);
        scene.background = textureCube;
        const gltfLoader = new GLTFLoader();
        gltfLoader.load(
          'festival.glb',
          (gltf) => {
            const model = gltf.scene;
            model.scale.set(8, 8, 8);
            scene.add(model);
            model.updateMatrixWorld(true);
            model.traverse((child) => {
              if (child.isMesh) {
                child.castShadow = true;
                child.receiveShadow = true;
                const box = new THREE.Box3().setFromObject(child);
                glbColliders.push(box);
                festivalMeshes.push(child);
              }
            });
          },
          undefined,
          (error) => {
            console.error('An error occurred loading festival.glb:', error);
          }
        );
        gltfLoader.load(
          'lantern.glb',
          (gltf) => {
            const baseModel = gltf.scene;
            baseModel.scale.set(0.25, 0.25, 0.25);

            const LANTERN_COUNT = 25;

            for (let i = 0; i < LANTERN_COUNT; i++) {
              const lantern = baseModel.clone(true);

              lantern.position.set(
                (Math.random() - 0.5) * 200, 
                75 + Math.random() * 20,     
                (Math.random() - 0.5) * 200  
              );

              lantern.rotation.y = Math.random() * Math.PI * 2;
              lantern.updateMatrixWorld(true);
              scene.add(lantern);
              
              lantern.userData.baseX = lantern.position.x;
              lantern.userData.baseY = lantern.position.y;
              lantern.userData.baseZ = lantern.position.z;
              lantern.userData.offset = Math.random() * 1000;
              lanterns.push(lantern);

              lantern.traverse((child) => {
                if (child.isMesh) {
                  child.castShadow = true;
                  child.receiveShadow = true;
                  const box = new THREE.Box3().setFromObject(child);
                  glbColliders.push(box);
                  festivalMeshes.push(child);
                }
              });
            }
          },
          undefined,
          (error) => {
            console.error('An error occurred loading lantern.glb:', error);
          }
        );

        const dragonLoader = new GLTFLoader();
        dragonLoader.load(
          'dragon.glb',
          (gltf) => {
            const dragon = gltf.scene;
            dragon.scale.set(3, 3, 3);
            dragon.position.set(-100, 35, -50);
            dragon.rotation.y = Math.PI * 0.75;
            scene.add(dragon);
            dragon.updateMatrixWorld(true);
            dragon.traverse((child) => {
              if (child.isMesh) {
                child.castShadow = true;
                child.receiveShadow = true;
                const box = new THREE.Box3().setFromObject(child);
                glbColliders.push(box);
                festivalMeshes.push(child);
              }
            });
          },
          undefined,
          (error) => {
            console.error('An error occurred loading dragon.glb:', error);
          }
        );

        const lionLoader = new GLTFLoader();
        lionLoader.load(
          'lion.glb',
          (gltf) => {
            const lionModel = gltf.scene;
            lionModel.scale.set(300, 300, 300);
            lionModel.position.set(150, 0, 0);
            lionModel.rotation.y = 150;
            scene.add(lionModel);
            const mixer = new THREE.AnimationMixer(lionModel);
            const clip = THREE.AnimationClip.findByName(gltf.animations, 'Take 001');
            if (clip) {
              const action = mixer.clipAction(clip);
              action.loop = THREE.LoopRepeat;
              action.play();
            }
            mixers.push(mixer);
          },
          undefined,
          (error) => {
            console.error('An error occurred loading lion.glb:', error);
          }
        );
        const horseLoader = new GLTFLoader();
        horseLoader.load(
          'horse.glb',
          (gltf) => {
            const horse = gltf.scene;
            horse.scale.set(1, 1, 1);
            horse.position.set(25, 8, 0);
            horse.rotation.y = Math.PI;
            scene.add(horse);
            horse.updateMatrixWorld(true);
            horse.traverse((child) => {
              if (child.isMesh) {
                child.castShadow = true;
                child.receiveShadow = true;
                const box = new THREE.Box3().setFromObject(child);
                glbColliders.push(box);
                festivalMeshes.push(child);
              }
            });
          },
          undefined,
          (error) => {
            console.error('An error occurred loading horse.glb:', error);
          }
        );

        horseLoader.load(
          'horse2.glb',
          (gltf) => {
            const horse = gltf.scene;
            horse.scale.set(150, 150, 150);
            horse.position.set(-140, 35, -50);
            horse.rotation.y = Math.PI;
            scene.add(horse);
            horse.updateMatrixWorld(true);
            horse.traverse((child) => {
              if (child.isMesh) {
                child.castShadow = true;
                child.receiveShadow = true;
                const box = new THREE.Box3().setFromObject(child);
                glbColliders.push(box);
                festivalMeshes.push(child);
              }
            });
          },
          undefined,
          (error) => {
            console.error('An error occurred loading horse.glb:', error);
          }
        );
        const drumLoader = new GLTFLoader();
        drumLoader.load(
          'drum.glb',
          (gltf) => {
            const drum = gltf.scene;
            drum.scale.set(4, 4, 4);
            drum.position.set(-120, 37, -88);
            drum.rotation.y = Math.PI;
            scene.add(drum);
            drum.updateMatrixWorld(true);
            drum.traverse((child) => {
              if (child.isMesh) {
                child.castShadow = true;
                child.receiveShadow = true;
                const box = new THREE.Box3().setFromObject(child);
                glbColliders.push(box);
                festivalMeshes.push(child);
              }
            });
          },
          undefined,
          (error) => {
            console.error('An error occurred loading drum.glb:', error);
          }
        );

        drumLoader.load(
          'drum.glb',
          (gltf) => {
            const drum = gltf.scene;
            drum.scale.set(4, 4, 4);
            drum.position.set(-109, 37, -80);
            drum.rotation.y = Math.PI;
            scene.add(drum);
            drum.updateMatrixWorld(true);
            drum.traverse((child) => {
              if (child.isMesh) {
                child.castShadow = true;
                child.receiveShadow = true;
                const box = new THREE.Box3().setFromObject(child);
                glbColliders.push(box);
                festivalMeshes.push(child);
              }
            });
          },
          undefined,
          (error) => {
            console.error('An error occurred loading drum.glb:', error);
          }
        );

        drumLoader.load(
          'drum.glb',
          (gltf) => {
            const drum = gltf.scene;
            drum.scale.set(4, 4, 4);
            drum.position.set(-95, 37, -70);
            drum.rotation.y = Math.PI;
            scene.add(drum);
            drum.updateMatrixWorld(true);
            drum.traverse((child) => {
              if (child.isMesh) {
                child.castShadow = true;
                child.receiveShadow = true;
                const box = new THREE.Box3().setFromObject(child);
                glbColliders.push(box);
                festivalMeshes.push(child);
              }
            });
          },
          undefined,
          (error) => {
            console.error('An error occurred loading drum.glb:', error);
          }
        );

        const envelopeLoader = new GLTFLoader();
        envelopeLoader.load(
          'envelope.glb',
          (gltf) => {
            const baseEnvelope = gltf.scene;
            baseEnvelope.scale.set(100, 100, 100);

            const ENVELOPE_COUNT = 35;

            for (let i = 0; i < ENVELOPE_COUNT; i++) {
              const envelope = baseEnvelope.clone(true);

              envelope.position.set(
                (Math.random() - 0.5) * 120,
                0,
                (Math.random() - 0.5) * 120
              );

              envelope.rotation.y = Math.random() * Math.PI * 2;

              scene.add(envelope);
              envelope.updateMatrixWorld(true);

              envelope.traverse((child) => {
                if (child.isMesh) {
                  child.castShadow = true;
                  child.receiveShadow = true;
                  const box = new THREE.Box3().setFromObject(child);
                  glbColliders.push(box);
                  festivalMeshes.push(child);
                }
              });
            }
          },
          undefined,
          (error) => {
            console.error('An error occurred loading envelope.glb:', error);
          }
        );


        const fireworkBoxLoader = new GLTFLoader();
        fireworkBoxLoader.load(
          'fireworkbox.glb',
          (gltf) => {
            const fireworkBox = gltf.scene;
            fireworkBox.scale.set(5, 5, 5);
            fireworkBox.position.set(60, 0, 25);
            fireworkBox.rotation.y = Math.PI * 1.2;
            scene.add(fireworkBox);
            fireworkBox.updateMatrixWorld(true);
            fireworkBox.traverse((child) => {
              if (child.isMesh) {
                child.castShadow = true;
                child.receiveShadow = true;
                const box = new THREE.Box3().setFromObject(child);
                glbColliders.push(box);
                festivalMeshes.push(child);
              }
            });
          },
          undefined,
          (error) => {
            console.error('An error occurred loading fireworkbox.glb:', error);
          }
        );

        fireworkBoxLoader.load(
          'fireworkbox.glb',
          (gltf) => {
            const fireworkBox = gltf.scene;
            fireworkBox.scale.set(5, 5, 5);
            fireworkBox.position.set(50, 0, -25);
            fireworkBox.rotation.y = Math.PI * 1.7;
            scene.add(fireworkBox);
            fireworkBox.updateMatrixWorld(true);
            fireworkBox.traverse((child) => {
              if (child.isMesh) {
                child.castShadow = true;
                child.receiveShadow = true;
                const box = new THREE.Box3().setFromObject(child);
                glbColliders.push(box);
                festivalMeshes.push(child);
              }
            });
          },
          undefined,
          (error) => {
            console.error('An error occurred loading fireworkbox.glb:', error);
          }
        );


        const fireworkLoader = new GLTFLoader();
        fireworkLoader.load(
          'firework.glb',
          (gltf) => {
            function createFireworkInstance(delaySeconds) {
              const firework = gltf.scene.clone(true);
              firework.scale.set(3, 3, 3);
              firework.position.set(
                (Math.random() - 0.5) * 200,
                60 + Math.random() * 20,
                (Math.random() - 0.5) * 200
              );
              scene.add(firework);
              const mixer = new THREE.AnimationMixer(firework);
              const clip = THREE.AnimationClip.findByName(gltf.animations, 'CINEMA_4D_Main');
              if (clip) {
                const action = mixer.clipAction(clip);
                action.loop = THREE.LoopRepeat;
                action.paused = true;
                setTimeout(() => {
                  action.paused = false;
                  action.reset();
                  action.play();
                }, delaySeconds * 1000);
              }
              mixer.addEventListener('loop', () => {
                firework.position.set(
                  (Math.random() - 0.5) * 200,
                  60 + Math.random() * 20,
                  (Math.random() - 0.5) * 200
                );
              });
              mixers.push(mixer);
            }
            createFireworkInstance(0);
            createFireworkInstance(2);
            createFireworkInstance(4);
          },
          undefined,
          (error) => {
            console.error('An error occurred loading firework.glb:', error);
          }
        );
        function explodeText(message = "Moonlit Festival") {
          const canvas = document.createElement("canvas");
          const size = 1024;
          canvas.width = size;
          canvas.height = size / 2;

          const ctx = canvas.getContext("2d");
          ctx.clearRect(0, 0, canvas.width, canvas.height);

          ctx.fillStyle = "white";
          ctx.font = "bold 70px sans-serif";

          ctx.textAlign = "center";
          ctx.textBaseline = "middle";
          ctx.fillText(message, canvas.width / 2, canvas.height / 2);

          const imageData = ctx.getImageData(0, 0, canvas.width, canvas.height).data;

          const positions = [];
          const velocities = [];

          for (let y = 0; y < canvas.height; y += 4) {
            for (let x = 0; x < canvas.width; x += 4) {
              const i = (y * canvas.width + x) * 4;
              if (imageData[i + 3] > 128) {
                const px = x - canvas.width / 2;
                const py = canvas.height / 2 - y;

                positions.push(px, py, 0);

                
                const dir = new THREE.Vector3(px, py, 0).normalize();
                dir.multiplyScalar(Math.random() * 2 + 0.5);

                velocities.push(dir.x, dir.y, dir.z);
              }
            }
          }

          const geometry = new THREE.BufferGeometry();
          geometry.setAttribute(
            "position",
            new THREE.Float32BufferAttribute(positions, 3)
          );

          const material = new THREE.PointsMaterial({
            color: 0xffd700,
            size: 2,
            transparent: true,
            opacity: 1,
          });

          const points = new THREE.Points(geometry, material);
          points.position.set(200, 250, -60);
          points.rotation.y = Math.PI * 1.5;
          scene.add(points);


          let life = 1.0;

          function update() {
            const pos = geometry.attributes.position;

            for (let i = 0; i < pos.count; i++) {
              pos.setX(i, pos.getX(i) + velocities[i * 3]);
              pos.setY(i, pos.getY(i) + velocities[i * 3 + 1]);
              pos.setZ(i, pos.getZ(i) + velocities[i * 3 + 2]);
            }

            pos.needsUpdate = true;

            life -= 0.01;
            material.opacity = life;

            if (life > 0) {
              requestAnimationFrame(update);
            } else {
              scene.remove(points);
              geometry.dispose();
              material.dispose();
            }
          }

          setTimeout(() => {
            update();
          }, 20000);
        }

        explodeText("Moonlit Festival");


      }
      function onWindowResize() {
        camera.aspect = window.innerWidth / window.innerHeight;
        camera.updateProjectionMatrix();
        renderer.setSize(window.innerWidth, window.innerHeight);
      }
      function onKeyDown(event) {
        switch (event.code) {
          case 'KeyW':
          case 'ArrowUp':
            moveForward = true;
            break;
          case 'KeyA':
          case 'ArrowLeft':
            moveLeft = true;
            break;
          case 'KeyS':
          case 'ArrowDown':
            moveBackward = true;
            break;
          case 'KeyD':
          case 'ArrowRight':
            moveRight = true;
            break;
        }
      }

      function onKeyUp(event) {
        switch (event.code) {
          case 'KeyW':
          case 'ArrowUp':
            moveForward = false;
            break;
          case 'KeyA':
          case 'ArrowLeft':
            moveLeft = false;
            break;
          case 'KeyS':
          case 'ArrowDown':
            moveBackward = false;
            break;
          case 'KeyD':
          case 'ArrowRight':
            moveRight = false;
            break;
        }
      }

      function animate() {
        requestAnimationFrame(animate);

        const time = performance.now();
        const delta = (time - prevTime) / 1000;

        velocityY -= GRAVITY * delta;
        controls.object.position.y += velocityY * delta;
        const prevCamPosition = controls.object.position.clone();

        if (controls.isLocked === true) {
          velocity.x -= velocity.x * 10.0 * delta;
          velocity.z -= velocity.z * 10.0 * delta;
          direction.z = Number(moveForward) - Number(moveBackward);
          direction.x = Number(moveRight) - Number(moveLeft);
          direction.normalize();
          const acceleration = 400.0;
          if (moveForward || moveBackward) velocity.z -= direction.z * acceleration * delta;
          if (moveLeft || moveRight) velocity.x -= direction.x * acceleration * delta;
          controls.moveRight(-velocity.x * delta);
          controls.moveForward(-velocity.z * delta);
          const yMin = 2;
          if (controls.object.position.y < yMin) {
            controls.object.position.y = yMin;
          }
        }

        if (festivalMeshes.length > 0) {
          const rayOrigin = controls.object.position.clone();
          rayOrigin.y += 10;
          downRaycaster.ray.origin.copy(rayOrigin);
          downRaycaster.ray.direction.set(0, -1, 0);
          const intersections = downRaycaster.intersectObjects(festivalMeshes, true);
          if (intersections.length > 0) {
            const groundY = intersections[0].point.y;
            const heightOffset = playerHeight * 0.5;
            const currentFeetY = controls.object.position.y - heightOffset;
            const targetFeetY = groundY;
            const stepHeight = playerHeight * 0.5;
            const deltaHeight = targetFeetY - currentFeetY;
            if (deltaHeight > -0.1 && deltaHeight < stepHeight) {
              controls.object.position.y = groundY + heightOffset;
              velocityY = 0;
            }
          }
          const forward = new THREE.Vector3(0, 0, -1).applyQuaternion(camera.quaternion).normalize();

          const forwardOrigin = controls.object.position.clone();
          forwardOrigin.y -= playerHeight * 0.5;
          forwardRaycaster.ray.origin.copy(forwardOrigin);
          forwardRaycaster.ray.direction.copy(forward);
          const obstacles = forwardRaycaster.intersectObjects(festivalMeshes, true);
          if (obstacles.length > 0) {
            const feetLevel = controls.object.position.y - playerHeight * 0.5; 
            const stepMargin = playerHeight * 0.1;
            const maxDistance = 1.0; 
            for (let j = 0; j < obstacles.length; j++) {
              const ob = obstacles[j];
              if (ob.distance < maxDistance) {
                if (ob.point.y > feetLevel + stepMargin) {
                  controls.object.position.x = prevCamPosition.x;
                  controls.object.position.z = prevCamPosition.z;
                  velocity.x = 0;
                  velocity.z = 0;
                  velocityY = 0;
                  break;
                }
              }
            }
          }
        }
        mixers.forEach((mixer) => mixer.update(delta));

        prevTime = time;
        const t = performance.now() * 0.001;

        lanterns.forEach((lantern) => {
          const o = lantern.userData.offset;

          lantern.position.y = lantern.userData.baseY + Math.sin(t + o) * 2;
          lantern.position.x = lantern.userData.baseX + Math.sin(t * 0.5 + o) * 3;
          lantern.position.z = lantern.userData.baseZ + Math.cos(t * 0.5 + o) * 3;
        });

        renderer.render(scene, camera);
      }
    </script>
  </body>
</html>
